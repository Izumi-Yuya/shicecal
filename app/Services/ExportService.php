<?php

namespace App\Services;

use App\Models\Facility;
use App\Models\File;
use App\Services\Traits\HandlesServiceErrors;
use Barryvdh\DomPDF\Facade\Pdf;
use Exception;
use Illuminate\Http\UploadedFile;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\View;
use Illuminate\Support\Str;
use ZipArchive;

/**
 * Unified export service handling PDF generation, CSV export, and file management
 * Merged from SecurePdfService, BatchPdfService, and FileService
 */
class ExportService
{
    use HandlesServiceErrors;

    // ========================================
    // PDF Generation Methods
    // ========================================

    /**
     * Generate secure PDF for a facility
     */
    public function generateSecureFacilityPdf(Facility $facility, array $options = []): string
    {
        try {
            // Load land info if not already loaded
            if (! $facility->relationLoaded('landInfo')) {
                $facility->load('landInfo');
            }

            $data = [
                'facility' => $facility,
                'landInfo' => $facility->landInfo,
                'generated_at' => now(),
                'generated_by' => Auth::user(),
            ];

            // Create new PDF document
            $pdf = new \TCPDF(PDF_PAGE_ORIENTATION, PDF_UNIT, PDF_PAGE_FORMAT, true, 'UTF-8', false);

            // Set document information
            $pdf->SetCreator('Shise-Cal System');
            $pdf->SetAuthor('Shise-Cal System');
            $pdf->SetTitle('施設情報帳票 - '.$facility->facility_name);
            $pdf->SetSubject('Facility Information Report');
            $pdf->SetKeywords('facility, report, shise-cal');

            // Set security settings
            $this->setSecuritySettings($pdf, $options);

            // Set default header data
            $pdf->SetHeaderData('', 0, '施設情報帳票', 'Facility Information Report - Generated by Shise-Cal System');

            // Set header and footer fonts
            $pdf->setHeaderFont(['dejavusans', '', 10]);
            $pdf->setFooterFont(['dejavusans', '', 8]);

            // Set default monospaced font
            $pdf->SetDefaultMonospacedFont(PDF_FONT_MONOSPACED);

            // Set margins
            $pdf->SetMargins(PDF_MARGIN_LEFT, PDF_MARGIN_TOP, PDF_MARGIN_RIGHT);
            $pdf->SetHeaderMargin(PDF_MARGIN_HEADER);
            $pdf->SetFooterMargin(PDF_MARGIN_FOOTER);

            // Set auto page breaks
            $pdf->SetAutoPageBreak(true, PDF_MARGIN_BOTTOM);

            // Set image scale factor
            $pdf->setImageScale(PDF_IMAGE_SCALE_RATIO);

            // Add a page
            $pdf->AddPage();

            // Generate HTML content
            $html = $this->generateHtmlContent($data);

            // Print text using writeHTMLCell()
            $pdf->writeHTML($html, true, false, true, false, '');

            // Add watermark for approved documents
            if ($facility->status === 'approved') {
                $this->addWatermark($pdf, '承認済');
            }

            return $pdf->Output('', 'S');
        } catch (Exception $e) {
            $this->logError('Secure PDF generation failed', [
                'facility_id' => $facility->id,
                'error' => $e->getMessage(),
            ]);
            throw $e;
        }
    }

    /**
     * Generate standard PDF using DomPDF
     */
    public function generateFacilityPdf(Facility $facility): string
    {
        try {
            // Load land info if not already loaded
            if (! $facility->relationLoaded('landInfo')) {
                $facility->load('landInfo');
            }

            $data = [
                'facility' => $facility,
                'landInfo' => $facility->landInfo,
                'generated_at' => now(),
                'generated_by' => Auth::user(),
            ];

            $pdf = Pdf::loadView('export.pdf.facility-report', $data);
            $pdf->setPaper('A4', 'portrait');

            return $pdf->output();
        } catch (Exception $e) {
            $this->logError('Standard PDF generation failed', [
                'facility_id' => $facility->id,
                'error' => $e->getMessage(),
            ]);
            throw $e;
        }
    }

    /**
     * Generate batch PDF with progress tracking
     */
    public function generateBatchPdf(Collection $facilities, array $options = []): array
    {
        $batchId = $this->generateBatchId();
        $useSecure = $options['secure'] ?? true;
        $totalFacilities = $facilities->count();

        // Initialize progress tracking
        $this->initializeProgress($batchId, $totalFacilities);

        try {
            $zipFilename = $this->generateZipFilename($useSecure);
            $zipPath = storage_path('app/temp/'.$zipFilename);

            // Ensure temp directory exists
            if (! file_exists(dirname($zipPath))) {
                mkdir(dirname($zipPath), 0755, true);
            }

            $zip = new ZipArchive;

            if ($zip->open($zipPath, ZipArchive::CREATE) !== true) {
                throw new Exception('ZIP ファイルの作成に失敗しました。');
            }

            $processedCount = 0;
            $errors = [];

            foreach ($facilities as $facility) {
                try {
                    // Update progress
                    $this->updateProgress($batchId, $processedCount, $totalFacilities, $facility->facility_name);

                    if ($useSecure) {
                        $pdfContent = $this->generateSecureFacilityPdf($facility, $options);
                        $pdfFilename = $this->generateSecureFilename($facility);
                    } else {
                        $pdfContent = $this->generateFacilityPdf($facility);
                        $pdfFilename = $this->generateStandardFilename($facility);
                    }

                    $zip->addFromString($pdfFilename, $pdfContent);
                    $processedCount++;
                } catch (Exception $e) {
                    $errors[] = [
                        'facility' => $facility->facility_name,
                        'error' => $e->getMessage(),
                    ];
                    $this->logError('Batch PDF generation error', [
                        'facility_id' => $facility->id,
                        'error' => $e->getMessage(),
                    ]);
                }
            }

            $zip->close();

            // Complete progress
            $this->completeProgress($batchId, $processedCount, $totalFacilities, $errors);

            return [
                'success' => true,
                'batch_id' => $batchId,
                'zip_path' => $zipPath,
                'zip_filename' => $zipFilename,
                'processed_count' => $processedCount,
                'total_count' => $totalFacilities,
                'errors' => $errors,
            ];
        } catch (Exception $e) {
            $this->failProgress($batchId, $e->getMessage());

            return [
                'success' => false,
                'batch_id' => $batchId,
                'error' => $e->getMessage(),
            ];
        }
    }

    /**
     * Get batch progress
     */
    public function getBatchProgress(string $batchId): array
    {
        return Cache::get("batch_pdf_progress_{$batchId}", [
            'status' => 'not_found',
            'message' => 'バッチが見つかりません',
        ]);
    }

    // ========================================
    // CSV Generation Methods
    // ========================================

    /**
     * Generate CSV content for facilities
     */
    public function generateCsv(array $facilityIds, array $fields): string
    {
        try {
            $facilities = Facility::whereIn('id', $facilityIds)
                ->with('landInfo')
                ->get();

            // Get available fields mapping
            $availableFields = $this->getAvailableFields();
            $selectedFields = array_intersect_key($availableFields, array_flip($fields));

            // Start with UTF-8 BOM to prevent character encoding issues
            $csvContent = "\xEF\xBB\xBF";

            // Create CSV header
            $header = array_values($selectedFields);
            $csvContent .= $this->arrayToCsvLine($header);

            // Add data rows
            foreach ($facilities as $facility) {
                $row = [];
                foreach ($fields as $field) {
                    $row[] = $this->getFieldValue($facility, $field);
                }
                $csvContent .= $this->arrayToCsvLine($row);
            }

            return $csvContent;
        } catch (Exception $e) {
            $this->logError('CSV generation failed', [
                'facility_count' => count($facilityIds),
                'error' => $e->getMessage(),
            ]);
            throw $e;
        }
    }

    /**
     * Get available fields for export
     */
    public function getAvailableFields(): array
    {
        return array_merge(
            $this->getFacilityFields(),
            $this->getLandInfoFields()
        );
    }

    /**
     * Preview field data for selected facilities
     */
    public function previewFieldData(array $facilityIds, array $fields): array
    {
        try {
            $facilities = Facility::whereIn('id', $facilityIds)
                ->with('landInfo')
                ->take(3) // Limit preview to 3 facilities
                ->get();

            $availableFields = $this->getAvailableFields();
            $selectedFields = array_intersect_key($availableFields, array_flip($fields));

            $previewData = [];
            foreach ($facilities as $facility) {
                $row = [];
                foreach ($fields as $field) {
                    $row[$field] = $this->getFieldValue($facility, $field);
                }
                $previewData[] = $row;
            }

            return [
                'fields' => $selectedFields,
                'preview_data' => $previewData,
                'total_facilities' => count($facilityIds),
                'preview_count' => count($previewData),
            ];
        } catch (Exception $e) {
            $this->logError('CSV preview failed', [
                'facility_count' => count($facilityIds),
                'error' => $e->getMessage(),
            ]);
            throw $e;
        }
    }

    // ========================================
    // File Management Methods
    // ========================================

    /**
     * Upload land document file
     */
    public function uploadFile(UploadedFile $file, int $facilityId, string $type): File
    {
        try {
            DB::beginTransaction();

            $facility = Facility::findOrFail($facilityId);
            $user = Auth::user();

            // Validate file
            $this->validateLandDocument($file);

            // Generate unique filename
            $filename = $this->generateUniqueFilename($file, $facility, $type);

            // Store file
            $path = $this->storeLandDocument($file, $facility, $filename);

            // Create file record
            $fileRecord = File::create([
                'facility_id' => $facility->id,
                'original_name' => $file->getClientOriginalName(),
                'file_path' => $path,
                'file_size' => $file->getSize(),
                'mime_type' => $file->getMimeType(),
                'land_document_type' => $type,
                'uploaded_by' => $user->id,
            ]);

            DB::commit();

            $this->logError('Land document uploaded successfully', [
                'file_id' => $fileRecord->id,
                'facility_id' => $facility->id,
                'document_type' => $type,
                'original_name' => $file->getClientOriginalName(),
                'uploaded_by' => $user->id,
            ]);

            return $fileRecord;
        } catch (Exception $e) {
            DB::rollBack();
            $this->logError('Failed to upload land document', [
                'facility_id' => $facilityId,
                'document_type' => $type,
                'error' => $e->getMessage(),
            ]);
            throw $e;
        }
    }

    /**
     * Download file
     */
    public function downloadFile(int $fileId)
    {
        try {
            $file = File::findOrFail($fileId);
            $user = Auth::user();

            // Verify this is a land document
            if (empty($file->land_document_type)) {
                throw new Exception('指定されたファイルは土地関連書類ではありません。');
            }

            // Check if file exists
            if (! Storage::exists($file->file_path)) {
                throw new Exception('ファイルが見つかりません。');
            }

            Log::info('Land document downloaded', [
                'file_id' => $file->id,
                'facility_id' => $file->facility_id,
                'document_type' => $file->land_document_type,
                'downloaded_by' => $user->id,
            ]);

            return Storage::download($file->file_path, $file->original_name);
        } catch (Exception $e) {
            $this->logError('File download failed', [
                'file_id' => $fileId,
                'error' => $e->getMessage(),
            ]);
            throw $e;
        }
    }

    /**
     * Delete file
     */
    public function deleteFile(int $fileId): bool
    {
        try {
            DB::beginTransaction();

            $file = File::findOrFail($fileId);
            $user = Auth::user();

            // Verify this is a land document
            if (empty($file->land_document_type)) {
                throw new Exception('指定されたファイルは土地関連書類ではありません。');
            }

            // Delete physical file
            if (Storage::exists($file->file_path)) {
                Storage::delete($file->file_path);
            }

            // Delete database record
            $file->delete();

            DB::commit();

            Log::info('Land document deleted', [
                'file_id' => $file->id,
                'facility_id' => $file->facility_id,
                'document_type' => $file->land_document_type,
                'deleted_by' => $user->id,
            ]);

            return true;
        } catch (Exception $e) {
            DB::rollBack();
            $this->logError('File deletion failed', [
                'file_id' => $fileId,
                'error' => $e->getMessage(),
            ]);
            throw $e;
        }
    }

    /**
     * Get files by facility
     */
    public function getFilesByFacility(int $facilityId): Collection
    {
        return File::where('facility_id', $facilityId)
            ->whereNotNull('land_document_type')
            ->with(['uploader'])
            ->orderBy('created_at', 'desc')
            ->get();
    }

    // ========================================
    // Protected Service Exception Method
    // ========================================

    protected function getServiceExceptionClass(): string
    {
        return \App\Exceptions\ServiceException::class;
    }

    // ========================================
    // Private Helper Methods - PDF Generation
    // ========================================

    /**
     * Set security settings for PDF
     */
    private function setSecuritySettings(\TCPDF $pdf, array $options = []): void
    {
        // Generate a secure password if not provided
        $userPassword = $options['user_password'] ?? $this->generateSecurePassword();
        $ownerPassword = $options['owner_password'] ?? $this->generateSecurePassword(16);

        // Set permissions (restrict editing, copying, printing)
        $permissions = [
            'print' => $options['allow_print'] ?? false,
            'modify' => false, // Always disable modification
            'copy' => false,   // Always disable copying
            'annot-forms' => false, // Disable annotations and forms
            'fill-forms' => false,  // Disable form filling
            'extract' => false,     // Disable content extraction
            'assemble' => false,    // Disable document assembly
            'print-high' => false,   // Disable high-quality printing
        ];

        // Set protection with passwords and permissions
        $pdf->SetProtection($permissions, $userPassword, $ownerPassword, 0, null);

        // Add metadata to track document authenticity
        $pdf->SetCreator('Shise-Cal System v1.0');
        $pdf->SetAuthor(Auth::user()->email);
        $pdf->SetTitle('Secure Facility Report - '.now()->toISOString());
        $pdf->SetSubject('Protected Facility Information');
        $pdf->SetKeywords('facility,report,secure,protected,shise-cal');
    }

    /**
     * Generate HTML content for the PDF
     */
    private function generateHtmlContent(array $data): string
    {
        return View::make('export.pdf.secure-facility-report', $data)->render();
    }

    /**
     * Add watermark to PDF
     */
    private function addWatermark(\TCPDF $pdf, string $text): void
    {
        // Get current page dimensions
        $pageWidth = $pdf->getPageWidth();
        $pageHeight = $pdf->getPageHeight();

        // Set watermark properties
        $pdf->SetAlpha(0.1); // Set transparency
        $pdf->SetFont('dejavusans', 'B', 48);
        $pdf->SetTextColor(128, 128, 128);

        // Calculate position for centered rotated text
        $x = $pageWidth / 2;
        $y = $pageHeight / 2;

        // Start transformation
        $pdf->StartTransform();

        // Rotate text 45 degrees
        $pdf->Rotate(45, $x, $y);

        // Add watermark text
        $pdf->Text($x - 30, $y, $text);

        // Stop transformation
        $pdf->StopTransform();

        // Reset alpha and color
        $pdf->SetAlpha(1);
        $pdf->SetTextColor(0, 0, 0);
    }

    /**
     * Generate secure password
     */
    private function generateSecurePassword(int $length = 12): string
    {
        $characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
        $password = '';

        for ($i = 0; $i < $length; $i++) {
            $password .= $characters[random_int(0, strlen($characters) - 1)];
        }

        return $password;
    }

    /**
     * Generate filename with security hash
     */
    public function generateSecureFilename(Facility $facility): string
    {
        $safeFilename = preg_replace('/[^a-zA-Z0-9\-_]/', '_', $facility->facility_name);
        $hash = substr(hash('sha256', $facility->id.$facility->updated_at.Auth::id()), 0, 8);

        return "secure_facility_report_{$facility->office_code}_{$safeFilename}_{$hash}_".now()->format('Y-m-d').'.pdf';
    }

    /**
     * Generate standard filename
     */
    private function generateStandardFilename(Facility $facility): string
    {
        $safeFilename = preg_replace('/[^a-zA-Z0-9\-_]/', '_', $facility->facility_name);

        return "facility_report_{$facility->office_code}_{$safeFilename}_".now()->format('Y-m-d').'.pdf';
    }

    /**
     * Generate batch ID
     */
    private function generateBatchId(): string
    {
        return 'batch_'.Auth::id().'_'.now()->format('YmdHis').'_'.substr(uniqid(), -6);
    }

    /**
     * Generate ZIP filename
     */
    private function generateZipFilename(bool $useSecure): string
    {
        $prefix = $useSecure ? 'secure_' : '';

        return $prefix.'facility_reports_'.now()->format('Y-m-d_H-i-s').'.zip';
    }

    // ========================================
    // Private Helper Methods - Progress Tracking
    // ========================================

    /**
     * Initialize progress tracking
     */
    private function initializeProgress(string $batchId, int $totalCount): void
    {
        $progress = [
            'status' => 'processing',
            'processed_count' => 0,
            'total_count' => $totalCount,
            'current_facility' => '',
            'started_at' => now()->toISOString(),
            'errors' => [],
        ];

        Cache::put("batch_pdf_progress_{$batchId}", $progress, now()->addHours(2));
    }

    /**
     * Update progress
     */
    private function updateProgress(string $batchId, int $processedCount, int $totalCount, string $currentFacility): void
    {
        $progress = Cache::get("batch_pdf_progress_{$batchId}", []);

        $progress['processed_count'] = $processedCount;
        $progress['current_facility'] = $currentFacility;
        $progress['percentage'] = round(($processedCount / $totalCount) * 100, 1);

        Cache::put("batch_pdf_progress_{$batchId}", $progress, now()->addHours(2));
    }

    /**
     * Complete progress
     */
    private function completeProgress(string $batchId, int $processedCount, int $totalCount, array $errors): void
    {
        $progress = Cache::get("batch_pdf_progress_{$batchId}", []);

        $progress['status'] = 'completed';
        $progress['processed_count'] = $processedCount;
        $progress['percentage'] = 100;
        $progress['completed_at'] = now()->toISOString();
        $progress['errors'] = $errors;

        Cache::put("batch_pdf_progress_{$batchId}", $progress, now()->addHours(24));
    }

    /**
     * Fail progress
     */
    private function failProgress(string $batchId, string $error): void
    {
        $progress = Cache::get("batch_pdf_progress_{$batchId}", []);

        $progress['status'] = 'failed';
        $progress['error'] = $error;
        $progress['failed_at'] = now()->toISOString();

        Cache::put("batch_pdf_progress_{$batchId}", $progress, now()->addHours(24));
    }

    // ========================================
    // Private Helper Methods - CSV Generation
    // ========================================

    /**
     * Convert array to CSV line
     */
    private function arrayToCsvLine(array $data): string
    {
        $output = fopen('php://temp', 'r+');
        fputcsv($output, $data);
        rewind($output);
        $line = fgets($output);
        fclose($output);

        return $line;
    }

    /**
     * Get facility fields for CSV export
     */
    private function getFacilityFields(): array
    {
        return [
            'company_name' => '会社名',
            'office_code' => '事業所コード',
            'designation_number' => '指定番号',
            'facility_name' => '施設名',
            'postal_code' => '郵便番号',
            'address' => '住所',
            'phone_number' => '電話番号',
            'fax_number' => 'FAX番号',
            'status' => 'ステータス',
            'approved_at' => '承認日時',
            'created_at' => '作成日時',
            'updated_at' => '更新日時',
        ];
    }

    /**
     * Get land information fields for CSV export
     */
    private function getLandInfoFields(): array
    {
        return [
            'land_ownership_type' => '土地所有形態',
            'land_parking_spaces' => '敷地内駐車場台数',
            'land_site_area_sqm' => '敷地面積(㎡)',
            'land_site_area_tsubo' => '敷地面積(坪数)',
            'land_purchase_price' => '購入金額',
            'land_unit_price_per_tsubo' => '坪単価',
            'land_monthly_rent' => '家賃',
            'land_contract_start_date' => '契約開始日',
            'land_contract_end_date' => '契約終了日',
            'land_contract_period_text' => '契約年数',
            'land_auto_renewal' => '自動更新の有無',
            'land_management_company_name' => '管理会社名',
            'land_management_company_postal_code' => '管理会社郵便番号',
            'land_management_company_address' => '管理会社住所',
            'land_management_company_building' => '管理会社建物名',
            'land_management_company_phone' => '管理会社電話番号',
            'land_management_company_fax' => '管理会社FAX番号',
            'land_management_company_email' => '管理会社メールアドレス',
            'land_management_company_url' => '管理会社URL',
            'land_management_company_notes' => '管理会社備考',
            'land_owner_name' => 'オーナー名',
            'land_owner_postal_code' => 'オーナー郵便番号',
            'land_owner_address' => 'オーナー住所',
            'land_owner_building' => 'オーナー建物名',
            'land_owner_phone' => 'オーナー電話番号',
            'land_owner_fax' => 'オーナーFAX番号',
            'land_owner_email' => 'オーナーメールアドレス',
            'land_owner_url' => 'オーナーURL',
            'land_owner_notes' => 'オーナー備考',
            'land_notes' => '土地備考',
            'land_status' => '土地情報ステータス',
            'land_approved_at' => '土地情報承認日時',
        ];
    }

    /**
     * Get formatted field value for a facility
     */
    private function getFieldValue(Facility $facility, string $field)
    {
        // Handle land information fields
        if (str_starts_with($field, 'land_')) {
            return $this->getLandInfoFieldValue($facility->landInfo, $field);
        }

        // Handle facility fields
        switch ($field) {
            case 'status':
                return $this->getStatusLabel($facility->status);
            case 'approved_at':
                return $facility->approved_at ? $facility->approved_at->format('Y-m-d H:i:s') : '';
            case 'created_at':
                return $facility->created_at->format('Y-m-d H:i:s');
            case 'updated_at':
                return $facility->updated_at->format('Y-m-d H:i:s');
            default:
                return $facility->{$field} ?? '';
        }
    }

    /**
     * Get formatted land information field value
     */
    private function getLandInfoFieldValue($landInfo, string $field)
    {
        if (! $landInfo) {
            return '';
        }

        $fieldName = str_replace('land_', '', $field);

        switch ($fieldName) {
            case 'ownership_type':
                return $this->getOwnershipTypeLabel($landInfo->ownership_type);
            case 'parking_spaces':
                return $landInfo->parking_spaces ?? '';
            case 'site_area_sqm':
                return $landInfo->site_area_sqm ? number_format($landInfo->site_area_sqm, 2) : '';
            case 'site_area_tsubo':
                return $landInfo->site_area_tsubo ? number_format($landInfo->site_area_tsubo, 2) : '';
            case 'purchase_price':
                return $landInfo->purchase_price ? number_format($landInfo->purchase_price) : '';
            case 'unit_price_per_tsubo':
                return $landInfo->unit_price_per_tsubo ? number_format($landInfo->unit_price_per_tsubo) : '';
            case 'monthly_rent':
                return $landInfo->monthly_rent ? number_format($landInfo->monthly_rent) : '';
            case 'contract_start_date':
                return $landInfo->contract_start_date ? $landInfo->contract_start_date->format('Y/m/d') : '';
            case 'contract_end_date':
                return $landInfo->contract_end_date ? $landInfo->contract_end_date->format('Y/m/d') : '';
            case 'auto_renewal':
                return $this->getAutoRenewalLabel($landInfo->auto_renewal);
            case 'status':
                return $this->getStatusLabel($landInfo->status);
            case 'approved_at':
                return $landInfo->approved_at ? $landInfo->approved_at->format('Y-m-d H:i:s') : '';
            default:
                return $landInfo->{$fieldName} ?? '';
        }
    }

    /**
     * Get status label in Japanese
     */
    private function getStatusLabel(string $status): string
    {
        $statusLabels = [
            'draft' => '下書き',
            'pending_approval' => '承認待ち',
            'approved' => '承認済み',
        ];

        return $statusLabels[$status] ?? $status;
    }

    /**
     * Get ownership type label in Japanese
     */
    private function getOwnershipTypeLabel(?string $ownershipType): string
    {
        if (! $ownershipType) {
            return '';
        }

        $ownershipLabels = [
            'owned' => '自社所有',
            'leased' => '賃貸',
            'other' => 'その他',
        ];

        return $ownershipLabels[$ownershipType] ?? $ownershipType;
    }

    /**
     * Get auto renewal label in Japanese
     */
    private function getAutoRenewalLabel(?bool $autoRenewal): string
    {
        if ($autoRenewal === null) {
            return '';
        }

        return $autoRenewal ? 'あり' : 'なし';
    }

    // ========================================
    // Private Helper Methods - File Management
    // ========================================

    /**
     * Validate land document file
     */
    protected function validateLandDocument(UploadedFile $file): void
    {
        // Check if file is valid
        if (! $file->isValid()) {
            throw new Exception('アップロードされたファイルが無効です。');
        }

        // Check file size (10MB limit)
        $maxSize = 10 * 1024 * 1024; // 10MB in bytes
        if ($file->getSize() > $maxSize) {
            throw new Exception('ファイルサイズが10MBを超えています。');
        }

        // Check MIME type (PDF only)
        $allowedMimeTypes = ['application/pdf'];
        if (! in_array($file->getMimeType(), $allowedMimeTypes)) {
            throw new Exception('PDFファイルのみアップロード可能です。');
        }

        // Check file extension
        $allowedExtensions = ['pdf'];
        $extension = strtolower($file->getClientOriginalExtension());
        if (! in_array($extension, $allowedExtensions)) {
            throw new Exception('PDFファイルのみアップロード可能です。');
        }
    }

    /**
     * Generate unique filename for land document
     */
    protected function generateUniqueFilename(UploadedFile $file, Facility $facility, string $documentType): string
    {
        $extension = $file->getClientOriginalExtension();
        $timestamp = now()->format('YmdHis');
        $random = Str::random(8);

        return "facility_{$facility->id}_{$documentType}_{$timestamp}_{$random}.{$extension}";
    }

    /**
     * Store land document file
     */
    protected function storeLandDocument(UploadedFile $file, Facility $facility, string $filename): string
    {
        $directory = "facilities/{$facility->id}/land_documents";

        return $file->storeAs($directory, $filename);
    }

    /**
     * Get PDF metadata for verification
     */
    public function getPdfMetadata(Facility $facility): array
    {
        return [
            'document_type' => 'Facility Report',
            'facility_id' => $facility->id,
            'facility_name' => $facility->facility_name,
            'office_code' => $facility->office_code,
            'generated_at' => now()->toISOString(),
            'generated_by' => Auth::user()->email,
            'security_level' => 'Protected',
            'approval_status' => $facility->status,
            'approved_at' => $facility->approved_at?->toISOString(),
            'checksum' => hash('sha256', serialize([
                $facility->id,
                $facility->updated_at,
                Auth::id(),
                now()->format('Y-m-d'),
            ])),
        ];
    }

    /**
     * Get formatted file size
     */
    public function formatFileSize(int $bytes): string
    {
        $units = ['B', 'KB', 'MB', 'GB'];
        $bytes = max($bytes, 0);
        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
        $pow = min($pow, count($units) - 1);

        $bytes /= (1 << (10 * $pow));

        return round($bytes, 2).' '.$units[$pow];
    }

    /**
     * Get document type display name
     */
    public function getDocumentTypeDisplayName(string $documentType): string
    {
        $displayNames = [
            'lease_contract' => '賃貸借契約書・覚書',
            'property_register' => '謄本',
            'other' => 'その他',
        ];

        return $displayNames[$documentType] ?? $documentType;
    }

    /**
     * Clean up old batch data
     */
    public function cleanupOldBatches(): int
    {
        // This would typically be run as a scheduled job
        // For now, we'll just return 0 as a placeholder
        return 0;
    }
}
