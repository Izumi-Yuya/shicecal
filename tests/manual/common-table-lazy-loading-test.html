<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Common Table Lazy Loading Manual Test</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <style>
        .detail-label {
            background-color: #f8f9fa;
            font-weight: 600;
            padding: 0.5rem;
            border-right: 1px solid #dee2e6;
            width: 200px;
        }
        
        .detail-value {
            padding: 0.5rem;
        }
        
        .empty-field {
            color: #6c757d;
            font-style: italic;
        }
        
        .lazy-loaded-row {
            transition: opacity 300ms ease-in-out;
        }
        
        .loading {
            opacity: 0.6;
            pointer-events: none;
        }
        
        .performance-stats {
            background: #e3f2fd;
            border: 1px solid #2196f3;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
        }
        
        .test-controls {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .memory-usage {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 8px;
            margin: 5px 0;
            font-size: 11px;
        }
    </style>
</head>
<body>
    <div class="container mt-4">
        <h1>Common Table Lazy Loading Manual Test</h1>
        <p class="text-muted">共通テーブル遅延読み込み機能の手動テスト</p>
        
        <!-- Test Controls -->
        <div class="test-controls">
            <h5>テスト制御</h5>
            <div class="row">
                <div class="col-md-6">
                    <label for="batchSize" class="form-label">バッチサイズ:</label>
                    <select id="batchSize" class="form-select">
                        <option value="10">10行</option>
                        <option value="25" selected>25行</option>
                        <option value="50">50行</option>
                        <option value="100">100行</option>
                    </select>
                </div>
                <div class="col-md-6">
                    <label for="totalRows" class="form-label">総行数:</label>
                    <select id="totalRows" class="form-select">
                        <option value="100">100行</option>
                        <option value="250" selected>250行</option>
                        <option value="500">500行</option>
                        <option value="1000">1000行</option>
                    </select>
                </div>
            </div>
            <div class="mt-3">
                <button id="generateTable" class="btn btn-primary">テーブル生成</button>
                <button id="clearTable" class="btn btn-secondary">クリア</button>
                <button id="toggleAutoLoad" class="btn btn-outline-info">自動読み込み切替</button>
                <button id="showMemoryUsage" class="btn btn-outline-success">メモリ使用量表示</button>
            </div>
            <div class="mt-2">
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="enablePerformanceLogging" checked>
                    <label class="form-check-label" for="enablePerformanceLogging">
                        パフォーマンスログ有効
                    </label>
                </div>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="enableAnimation" checked>
                    <label class="form-check-label" for="enableAnimation">
                        フェードインアニメーション有効
                    </label>
                </div>
            </div>
        </div>
        
        <!-- Performance Stats -->
        <div id="performanceStats" class="performance-stats" style="display: none;">
            <h6>パフォーマンス統計</h6>
            <div id="statsContent"></div>
        </div>
        
        <!-- Memory Usage -->
        <div id="memoryUsage" class="memory-usage" style="display: none;">
            <strong>メモリ使用量:</strong> <span id="memoryContent"></span>
        </div>
        
        <!-- Test Table Container -->
        <div id="tableContainer">
            <!-- Dynamic table will be inserted here -->
        </div>
        
        <!-- Test Results -->
        <div id="testResults" class="mt-4" style="display: none;">
            <h5>テスト結果</h5>
            <div id="resultsContent" class="alert alert-info"></div>
        </div>
    </div>

    <!-- Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Common Table Lazy Loading Test Implementation
        class CommonTableLazyLoaderTest {
            constructor() {
                this.currentLoader = null;
                this.performanceData = [];
                this.autoLoad = false;
                this.init();
            }
            
            init() {
                this.bindEvents();
                this.setupPerformanceMonitoring();
            }
            
            bindEvents() {
                document.getElementById('generateTable').addEventListener('click', () => this.generateTable());
                document.getElementById('clearTable').addEventListener('click', () => this.clearTable());
                document.getElementById('toggleAutoLoad').addEventListener('click', () => this.toggleAutoLoad());
                document.getElementById('showMemoryUsage').addEventListener('click', () => this.showMemoryUsage());
                
                // Listen for custom events
                document.addEventListener('commonTableBatchLoaded', (e) => this.onBatchLoaded(e));
            }
            
            setupPerformanceMonitoring() {
                // Monitor performance every 5 seconds
                setInterval(() => {
                    if (this.currentLoader) {
                        this.updatePerformanceStats();
                    }
                }, 5000);
            }
            
            generateTable() {
                const batchSize = parseInt(document.getElementById('batchSize').value);
                const totalRows = parseInt(document.getElementById('totalRows').value);
                const enablePerformanceLogging = document.getElementById('enablePerformanceLogging').checked;
                const enableAnimation = document.getElementById('enableAnimation').checked;
                
                this.clearTable();
                
                const startTime = performance.now();
                
                // Generate test data
                const allData = this.generateTestData(totalRows);
                const batches = this.splitIntoBatches(allData, batchSize);
                const initialBatch = batches[0] || [];
                const remainingBatches = batches.slice(1);
                
                // Create table HTML
                const tableHTML = this.createTableHTML(initialBatch, remainingBatches, batchSize);
                document.getElementById('tableContainer').innerHTML = tableHTML;
                
                // Initialize lazy loader
                this.currentLoader = new CommonTableLazyLoader({
                    batchSize: batchSize,
                    autoLoad: this.autoLoad,
                    fadeInDuration: enableAnimation ? 300 : 0,
                    performanceLogging: enablePerformanceLogging
                });
                
                const endTime = performance.now();
                
                // Show performance stats
                this.showPerformanceStats();
                this.logPerformance('Table Generation', endTime - startTime, {
                    totalRows: totalRows,
                    batchSize: batchSize,
                    initialBatch: initialBatch.length,
                    remainingBatches: remainingBatches.length
                });
            }
            
            generateTestData(totalRows) {
                const data = [];
                const categories = ['基本情報', '詳細情報', '設定情報', '管理情報', 'システム情報'];
                const statuses = ['有効', '無効', '保留', '確認中', '完了'];
                
                for (let i = 0; i < totalRows; i++) {
                    const category = categories[i % categories.length];
                    const status = statuses[i % statuses.length];
                    
                    data.push({
                        type: 'standard',
                        cells: [
                            {
                                label: `${category}${Math.floor(i / 5) + 1}`,
                                value: null,
                                type: 'text'
                            },
                            {
                                label: null,
                                value: `データ項目 ${i + 1}`,
                                type: 'text'
                            }
                        ]
                    });
                    
                    // Add status row
                    data.push({
                        type: 'standard',
                        cells: [
                            {
                                label: 'ステータス',
                                value: null,
                                type: 'text'
                            },
                            {
                                label: null,
                                value: status,
                                type: 'badge',
                                formatted_value: `<span class="badge bg-${this.getBadgeColor(status)}">${status}</span>`
                            }
                        ]
                    });
                }
                
                return data;
            }
            
            getBadgeColor(status) {
                const colors = {
                    '有効': 'success',
                    '無効': 'danger',
                    '保留': 'warning',
                    '確認中': 'info',
                    '完了': 'primary'
                };
                return colors[status] || 'secondary';
            }
            
            splitIntoBatches(data, batchSize) {
                const batches = [];
                for (let i = 0; i < data.length; i += batchSize) {
                    batches.push(data.slice(i, i + batchSize));
                }
                return batches;
            }
            
            createTableHTML(initialBatch, remainingBatches, batchSize) {
                const remainingRows = remainingBatches.reduce((total, batch) => total + batch.length, 0);
                
                return `
                    <div class="card facility-info-card detail-card-improved mb-3" data-lazy-loading="true">
                        <div class="card-header">
                            <h5 class="card-title mb-0">遅延読み込みテストテーブル</h5>
                            <small class="text-muted">大量データのため段階的に読み込みます。（総${initialBatch.length + remainingRows}行）</small>
                        </div>
                        <div class="card-body card-body-clean">
                            <div class="table-responsive table-responsive-md" role="region" aria-label="データテーブル">
                                <table class="table table-bordered facility-basic-info-table-clean" 
                                       role="table" 
                                       aria-label="遅延読み込みテストテーブルの詳細情報"
                                       data-responsive="true"
                                       data-mobile-optimized="true"
                                       data-performance-optimized="true">
                                    <caption class="sr-only">遅延読み込みテストテーブルの詳細情報</caption>
                                    <tbody id="table-body-lazy">
                                        ${this.renderRows(initialBatch)}
                                    </tbody>
                                </table>
                                
                                ${remainingRows > 0 ? `
                                    <div class="text-center mt-3">
                                        <button class="btn btn-outline-primary" id="load-more-rows" 
                                                data-total-batches="${remainingBatches.length + 1}" 
                                                data-current-batch="1"
                                                data-batch-size="${batchSize}">
                                            <i class="fas fa-chevron-down me-1"></i>
                                            さらに読み込む (${remainingRows}行)
                                        </button>
                                    </div>
                                    
                                    <script type="application/json" id="remaining-batches-data">
                                        ${JSON.stringify(remainingBatches)}
                                    </script>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;
            }
            
            renderRows(batch) {
                return batch.map(rowData => {
                    const cells = rowData.cells.map(cell => {
                        if (cell.label !== null && cell.label !== undefined) {
                            return `<td class="detail-label">${cell.label}</td>`;
                        } else {
                            const isEmpty = cell.value === null || cell.value === undefined || cell.value === '';
                            const cssClass = isEmpty ? 'detail-value empty-field' : 'detail-value';
                            const content = isEmpty ? '未設定' : (cell.formatted_value || cell.value);
                            return `<td class="${cssClass}">${content}</td>`;
                        }
                    }).join('');
                    
                    return `<tr>${cells}</tr>`;
                }).join('');
            }
            
            clearTable() {
                if (this.currentLoader) {
                    this.currentLoader.destroy();
                    this.currentLoader = null;
                }
                
                document.getElementById('tableContainer').innerHTML = '';
                document.getElementById('performanceStats').style.display = 'none';
                document.getElementById('memoryUsage').style.display = 'none';
                document.getElementById('testResults').style.display = 'none';
                
                this.performanceData = [];
            }
            
            toggleAutoLoad() {
                this.autoLoad = !this.autoLoad;
                const button = document.getElementById('toggleAutoLoad');
                button.textContent = this.autoLoad ? '自動読み込み: ON' : '自動読み込み: OFF';
                button.className = this.autoLoad ? 'btn btn-success' : 'btn btn-outline-info';
                
                if (this.currentLoader) {
                    this.currentLoader.options.autoLoad = this.autoLoad;
                }
            }
            
            showMemoryUsage() {
                const memoryDiv = document.getElementById('memoryUsage');
                const memoryContent = document.getElementById('memoryContent');
                
                if ('memory' in performance) {
                    const memory = performance.memory;
                    memoryContent.innerHTML = `
                        使用中: ${(memory.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB | 
                        合計: ${(memory.totalJSHeapSize / 1024 / 1024).toFixed(2)}MB | 
                        制限: ${(memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)}MB
                    `;
                } else {
                    memoryContent.textContent = 'メモリ情報は利用できません';
                }
                
                memoryDiv.style.display = 'block';
            }
            
            showPerformanceStats() {
                document.getElementById('performanceStats').style.display = 'block';
                this.updatePerformanceStats();
            }
            
            updatePerformanceStats() {
                const statsContent = document.getElementById('statsContent');
                const stats = this.performanceData.slice(-5); // Show last 5 entries
                
                statsContent.innerHTML = stats.map(stat => 
                    `<div>${stat.timestamp}: ${stat.operation} - ${stat.duration.toFixed(2)}ms ${JSON.stringify(stat.details)}</div>`
                ).join('');
            }
            
            logPerformance(operation, duration, details = {}) {
                this.performanceData.push({
                    timestamp: new Date().toLocaleTimeString(),
                    operation: operation,
                    duration: duration,
                    details: details
                });
                
                if (document.getElementById('performanceStats').style.display !== 'none') {
                    this.updatePerformanceStats();
                }
            }
            
            onBatchLoaded(event) {
                const stats = event.detail;
                this.logPerformance('Batch Loaded', 0, stats);
                
                // Show test results
                const resultsDiv = document.getElementById('testResults');
                const resultsContent = document.getElementById('resultsContent');
                
                resultsContent.innerHTML = `
                    <strong>バッチ ${stats.batch_loaded} 読み込み完了</strong><br>
                    バッチサイズ：${stats.batch_size}行<br>
                    残りバッチ：${stats.remaining_batches}<br>
                    ${stats.memory_usage ? `メモリ使用量：${stats.memory_usage.used}MB` : ''}
                `;
                
                resultsDiv.style.display = 'block';
            }
        }
        
        // Simplified CommonTableLazyLoader for testing
        class CommonTableLazyLoader {
            constructor(options = {}) {
                this.options = {
                    batchSize: 50,
                    loadMoreSelector: '#load-more-rows',
                    tableBodySelector: '#table-body-lazy',
                    batchDataSelector: '#remaining-batches-data',
                    loadingClass: 'loading',
                    fadeInDuration: 300,
                    autoLoad: false,
                    performanceLogging: false,
                    ...options
                };
                
                this.currentBatch = 1;
                this.batches = [];
                this.isLoading = false;
                this.totalBatches = 0;
                
                this.init();
            }
            
            init() {
                this.loadMoreBtn = document.querySelector(this.options.loadMoreSelector);
                this.tableBody = document.querySelector(this.options.tableBodySelector);
                this.batchDataElement = document.querySelector(this.options.batchDataSelector);
                
                if (!this.loadMoreBtn || !this.tableBody || !this.batchDataElement) {
                    console.warn('CommonTableLazyLoader: Required elements not found');
                    return;
                }
                
                this.loadBatchData();
                this.bindEvents();
                this.setupIntersectionObserver();
            }
            
            loadBatchData() {
                try {
                    this.batches = JSON.parse(this.batchDataElement.textContent);
                    this.totalBatches = this.batches.length + 1;
                    
                    if (this.options.performanceLogging) {
                        console.log(`CommonTableLazyLoader: Loaded ${this.batches.length} additional batches`);
                    }
                } catch (e) {
                    console.error('CommonTableLazyLoader: Failed to parse batch data:', e);
                    this.hideLazyLoadButton();
                }
            }
            
            bindEvents() {
                this.loadMoreBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    this.loadNextBatch();
                });
                
                this.loadMoreBtn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        this.loadNextBatch();
                    }
                });
            }
            
            setupIntersectionObserver() {
                if (!('IntersectionObserver' in window)) {
                    return;
                }
                
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting && !this.isLoading && this.hasMoreBatches()) {
                            if (this.options.autoLoad) {
                                this.loadNextBatch();
                            }
                        }
                    });
                }, {
                    rootMargin: '100px'
                });
                
                observer.observe(this.loadMoreBtn);
            }
            
            async loadNextBatch() {
                if (this.isLoading || !this.hasMoreBatches()) {
                    return;
                }
                
                this.isLoading = true;
                this.setLoadingState(true);
                
                const startTime = performance.now();
                
                try {
                    const batch = this.batches[this.currentBatch - 1];
                    const fragment = await this.createRowsFragment(batch);
                    
                    await this.appendRowsWithAnimation(fragment);
                    
                    this.currentBatch++;
                    this.updateLoadMoreButton();
                    
                    const endTime = performance.now();
                    this.logPerformanceStats(batch.length, endTime - startTime);
                    
                } catch (error) {
                    console.error('CommonTableLazyLoader: Error loading batch:', error);
                    this.showErrorMessage();
                } finally {
                    this.isLoading = false;
                    this.setLoadingState(false);
                }
            }
            
            async createRowsFragment(batch) {
                const fragment = document.createDocumentFragment();
                
                for (const rowData of batch) {
                    if (!rowData.cells || !Array.isArray(rowData.cells)) {
                        continue;
                    }
                    
                    const row = await this.createTableRow(rowData);
                    fragment.appendChild(row);
                }
                
                return fragment;
            }
            
            async createTableRow(rowData) {
                const row = document.createElement('tr');
                row.className = 'lazy-loaded-row';
                row.style.opacity = '0';
                
                if (rowData.type) {
                    row.classList.add(`row-type-${rowData.type}`);
                }
                
                for (const cellData of rowData.cells) {
                    const cell = await this.createTableCell(cellData);
                    row.appendChild(cell);
                }
                
                return row;
            }
            
            async createTableCell(cellData) {
                const cell = document.createElement('td');
                
                if (cellData.label !== undefined && cellData.label !== null) {
                    cell.className = 'detail-label';
                    cell.textContent = cellData.label;
                } else {
                    cell.className = 'detail-value';
                    
                    if (this.isEmpty(cellData.value)) {
                        cell.classList.add('empty-field');
                        cell.textContent = '未設定';
                    } else {
                        if (cellData.formatted_value) {
                            cell.innerHTML = cellData.formatted_value;
                        } else {
                            cell.textContent = cellData.value;
                        }
                    }
                }
                
                if (cellData.colspan && cellData.colspan > 1) {
                    cell.colSpan = cellData.colspan;
                }
                if (cellData.rowspan && cellData.rowspan > 1) {
                    cell.rowSpan = cellData.rowspan;
                }
                if (cellData.class) {
                    cell.className += ' ' + cellData.class;
                }
                
                return cell;
            }
            
            async appendRowsWithAnimation(fragment) {
                this.tableBody.appendChild(fragment);
                
                const newRows = this.tableBody.querySelectorAll('.lazy-loaded-row[style*="opacity: 0"]');
                
                return new Promise((resolve) => {
                    let completed = 0;
                    const total = newRows.length;
                    
                    if (total === 0) {
                        resolve();
                        return;
                    }
                    
                    newRows.forEach((row, index) => {
                        setTimeout(() => {
                            row.style.transition = `opacity ${this.options.fadeInDuration}ms ease-in-out`;
                            row.style.opacity = '1';
                            
                            setTimeout(() => {
                                completed++;
                                if (completed === total) {
                                    resolve();
                                }
                            }, this.options.fadeInDuration);
                        }, index * 50);
                    });
                });
            }
            
            setLoadingState(loading) {
                if (loading) {
                    this.loadMoreBtn.classList.add(this.options.loadingClass);
                    this.loadMoreBtn.disabled = true;
                    this.loadMoreBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>読み込み中...';
                } else {
                    this.loadMoreBtn.classList.remove(this.options.loadingClass);
                    this.loadMoreBtn.disabled = false;
                }
            }
            
            updateLoadMoreButton() {
                const remainingBatches = this.batches.length - this.currentBatch + 1;
                const remainingRows = this.batches.slice(this.currentBatch - 1).reduce((total, batch) => total + batch.length, 0);
                
                if (remainingRows > 0) {
                    this.loadMoreBtn.innerHTML = `<i class="fas fa-chevron-down me-1"></i>さらに読み込む (${remainingRows}行)`;
                } else {
                    this.hideLazyLoadButton();
                }
            }
            
            hideLazyLoadButton() {
                this.loadMoreBtn.style.display = 'none';
                
                const completionMessage = document.createElement('div');
                completionMessage.className = 'text-center text-muted mt-3';
                completionMessage.innerHTML = '<i class="fas fa-check-circle me-1"></i>すべてのデータを読み込みました';
                this.loadMoreBtn.parentNode.replaceChild(completionMessage, this.loadMoreBtn);
            }
            
            showErrorMessage() {
                const errorMessage = document.createElement('div');
                errorMessage.className = 'alert alert-warning mt-3';
                errorMessage.innerHTML = `
                    <i class="fas fa-exclamation-triangle me-1"></i>
                    データの読み込みに失敗しました。
                    <button class="btn btn-sm btn-outline-primary ms-2" onclick="location.reload()">
                        ページを再読み込み
                    </button>
                `;
                this.loadMoreBtn.parentNode.insertBefore(errorMessage, this.loadMoreBtn.nextSibling);
            }
            
            hasMoreBatches() {
                return this.currentBatch <= this.batches.length;
            }
            
            isEmpty(value) {
                return value === null || value === undefined || value === '';
            }
            
            logPerformanceStats(batchSize, loadTime) {
                const stats = {
                    batch_loaded: this.currentBatch,
                    batch_size: batchSize,
                    total_batches: this.totalBatches,
                    remaining_batches: this.batches.length - this.currentBatch + 1,
                    load_time_ms: loadTime,
                    memory_usage: this.getMemoryUsage()
                };
                
                if (this.options.performanceLogging) {
                    console.log('CommonTableLazyLoader: Batch loaded', stats);
                }
                
                const event = new CustomEvent('commonTableBatchLoaded', {
                    detail: stats
                });
                document.dispatchEvent(event);
            }
            
            getMemoryUsage() {
                if ('memory' in performance) {
                    return {
                        used: Math.round(performance.memory.usedJSHeapSize / 1024 / 1024),
                        total: Math.round(performance.memory.totalJSHeapSize / 1024 / 1024),
                        limit: Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024)
                    };
                }
                return null;
            }
            
            destroy() {
                if (this.loadMoreBtn) {
                    this.loadMoreBtn.removeEventListener('click', this.loadNextBatch);
                }
                
                this.batches = [];
                this.loadMoreBtn = null;
                this.tableBody = null;
                this.batchDataElement = null;
            }
        }
        
        // Initialize test when DOM is ready
        document.addEventListener('DOMContentLoaded', function() {
            new CommonTableLazyLoaderTest();
        });
    </script>
</body>
</html>